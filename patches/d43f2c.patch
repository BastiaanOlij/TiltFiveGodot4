diff --git a/doc/classes/RenderingServer.xml b/doc/classes/RenderingServer.xml
index c5d210f..fab55da 100644
--- a/doc/classes/RenderingServer.xml
+++ b/doc/classes/RenderingServer.xml
@@ -3069,6 +3069,15 @@
 				Returns the internal graphics handle for this texture object. For use when communicating with 3rd party APIs mostly with GDExternal.
 			</description>
 		</method>
+		<method name="texture_create_render_texture">
+			<return type="RID" />
+			<param index="0" name="width" type="int" />
+			<param index="1" name="height" type="int" />
+			<param index="2" name="layers" type="int" />
+			<description>
+				Returns a texture object sutable as a render target. For use when communicating with 3rd party APIs mostly with GDExternal.
+			</description>
+		</method>
 		<method name="texture_get_path" qualifiers="const">
 			<return type="String" />
 			<param index="0" name="texture" type="RID" />
diff --git a/drivers/gles3/storage/texture_storage.cpp b/drivers/gles3/storage/texture_storage.cpp
index 9c33ad0..bc9e9bf 100644
--- a/drivers/gles3/storage/texture_storage.cpp
+++ b/drivers/gles3/storage/texture_storage.cpp
@@ -802,6 +802,76 @@ RID TextureStorage::texture_create_external(Texture::Type p_type, Image::Format 
 	return texture_owner.make_rid(texture);
 }
 
+
+RID TextureStorage::texture_create_render_texture(int p_width, int p_height, int p_layers) {
+	ERR_FAIL_COND_V(p_height <= 0, RID());
+	ERR_FAIL_COND_V(p_width <= 0, RID());
+	ERR_FAIL_COND_V(p_layers <= 0, RID());
+
+	Texture texture;
+	texture.active = true;
+	texture.is_external = false;
+	texture.compressed = false;
+
+	texture.width = p_width;
+	texture.height = p_height;
+	texture.layers = p_layers;
+	texture.alloc_width = texture.width;
+	texture.alloc_height = texture.height;
+	texture.mipmaps = 1;
+	texture.real_format = texture.format = Image::FORMAT_RGBA8;
+
+	if(p_layers > 1) {
+		texture.type = Texture::TYPE_LAYERED;
+		texture.target = GL_TEXTURE_2D_ARRAY;
+	} else {
+		texture.type = Texture::TYPE_2D;
+		texture.target = GL_TEXTURE_2D;
+	}
+	texture.gl_format_cache = GL_RGBA;
+	texture.gl_internal_format_cache = GL_RGBA8;
+	texture.gl_type_cache = GL_UNSIGNED_BYTE;
+
+	glDisable(GL_SCISSOR_TEST);
+	glColorMask(1, 1, 1, 1);
+	glDepthMask(GL_FALSE);
+
+	glGenTextures(1, &texture.tex_id);
+	glBindTexture(texture.target, texture.tex_id);
+
+	if (p_layers > 1) {
+		glTexImage3D(
+			texture.target, 
+			0, 
+			texture.gl_internal_format_cache, 
+			texture.alloc_width, 
+			texture.alloc_height, 
+			p_layers, 
+			0, 
+			texture.gl_format_cache, 
+			texture.gl_type_cache, 
+			nullptr);
+	} else {
+		glTexImage2D(
+			texture.target, 
+			0, 
+			texture.gl_internal_format_cache, 
+			texture.alloc_width, 
+			texture.alloc_height, 
+			0, 
+			texture.gl_format_cache, 
+			texture.gl_type_cache, 
+			nullptr);
+	}
+
+	glTexParameteri(texture.target, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+	glTexParameteri(texture.target, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+	glTexParameteri(texture.target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+	glTexParameteri(texture.target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+	return texture_owner.make_rid(texture);
+}
+
 void TextureStorage::texture_2d_update(RID p_texture, const Ref<Image> &p_image, int p_layer) {
 	texture_set_data(p_texture, p_image, p_layer);
 #ifdef TOOLS_ENABLED
diff --git a/drivers/gles3/storage/texture_storage.h b/drivers/gles3/storage/texture_storage.h
index e7c9fa4..c6d6018 100644
--- a/drivers/gles3/storage/texture_storage.h
+++ b/drivers/gles3/storage/texture_storage.h
@@ -504,6 +504,7 @@ public:
 	virtual void texture_proxy_initialize(RID p_texture, RID p_base) override; //all slices, then all the mipmaps, must be coherent
 
 	RID texture_create_external(Texture::Type p_type, Image::Format p_format, unsigned int p_image, int p_width, int p_height, int p_depth, int p_layers, RS::TextureLayeredType p_layered_type = RS::TEXTURE_LAYERED_2D_ARRAY);
+	RID texture_create_render_texture(int p_width, int p_height, int p_layers) override;
 
 	virtual void texture_2d_update(RID p_texture, const Ref<Image> &p_image, int p_layer = 0) override;
 	virtual void texture_3d_update(RID p_texture, const Vector<Ref<Image>> &p_data) override{};
diff --git a/servers/rendering/dummy/storage/texture_storage.h b/servers/rendering/dummy/storage/texture_storage.h
index 768b1ba..b21233a 100644
--- a/servers/rendering/dummy/storage/texture_storage.h
+++ b/servers/rendering/dummy/storage/texture_storage.h
@@ -98,6 +98,12 @@ public:
 	virtual void texture_3d_update(RID p_texture, const Vector<Ref<Image>> &p_data) override{};
 	virtual void texture_proxy_update(RID p_proxy, RID p_base) override{};
 
+	virtual RID texture_create_render_texture(int p_width, int p_height, int p_layers) override {
+		DummyTexture *texture = memnew(DummyTexture);
+		ERR_FAIL_COND_V(!texture, RID());
+		return texture_owner.make_rid(texture);
+	};
+
 	//these two APIs can be used together or in combination with the others.
 	virtual void texture_2d_placeholder_initialize(RID p_texture) override{};
 	virtual void texture_2d_layered_placeholder_initialize(RID p_texture, RenderingServer::TextureLayeredType p_layered_type) override{};
diff --git a/servers/rendering/renderer_rd/storage_rd/texture_storage.cpp b/servers/rendering/renderer_rd/storage_rd/texture_storage.cpp
index 3d6092a..dd2da78 100644
--- a/servers/rendering/renderer_rd/storage_rd/texture_storage.cpp
+++ b/servers/rendering/renderer_rd/storage_rd/texture_storage.cpp
@@ -1106,6 +1106,11 @@ void TextureStorage::texture_proxy_initialize(RID p_texture, RID p_base) {
 	tex->proxies.push_back(p_texture);
 }
 
+
+RID TextureStorage::texture_create_render_texture(int p_width, int p_height, int p_layers) {
+	return RID();
+}
+
 void TextureStorage::_texture_2d_update(RID p_texture, const Ref<Image> &p_image, int p_layer, bool p_immediate) {
 	ERR_FAIL_COND(p_image.is_null() || p_image->is_empty());
 
diff --git a/servers/rendering/renderer_rd/storage_rd/texture_storage.h b/servers/rendering/renderer_rd/storage_rd/texture_storage.h
index 8f021f3..7c183c6 100644
--- a/servers/rendering/renderer_rd/storage_rd/texture_storage.h
+++ b/servers/rendering/renderer_rd/storage_rd/texture_storage.h
@@ -469,6 +469,8 @@ public:
 	virtual void texture_3d_initialize(RID p_texture, Image::Format, int p_width, int p_height, int p_depth, bool p_mipmaps, const Vector<Ref<Image>> &p_data) override;
 	virtual void texture_proxy_initialize(RID p_texture, RID p_base) override; //all slices, then all the mipmaps, must be coherent
 
+	virtual RID texture_create_render_texture(int p_width, int p_height, int p_layers);
+
 	virtual void texture_2d_update(RID p_texture, const Ref<Image> &p_image, int p_layer = 0) override;
 	virtual void texture_3d_update(RID p_texture, const Vector<Ref<Image>> &p_data) override;
 	virtual void texture_proxy_update(RID p_proxy, RID p_base) override;
diff --git a/servers/rendering/rendering_server_default.h b/servers/rendering/rendering_server_default.h
index 66cf32b..32fdf47 100644
--- a/servers/rendering/rendering_server_default.h
+++ b/servers/rendering/rendering_server_default.h
@@ -215,6 +215,7 @@ public:
 	FUNC2(texture_set_force_redraw_if_visible, RID, bool)
 	FUNC2RC(RID, texture_get_rd_texture, RID, bool)
 	FUNC2RC(uint64_t, texture_get_native_handle, RID, bool)
+	FUNC3R(RID, texture_create_render_texture, int, int, int )
 
 	/* SHADER API */
 
diff --git a/servers/rendering/storage/texture_storage.h b/servers/rendering/storage/texture_storage.h
index 93b32bd..a83d679 100644
--- a/servers/rendering/storage/texture_storage.h
+++ b/servers/rendering/storage/texture_storage.h
@@ -75,6 +75,8 @@ public:
 	virtual void texture_3d_update(RID p_texture, const Vector<Ref<Image>> &p_data) = 0;
 	virtual void texture_proxy_update(RID p_proxy, RID p_base) = 0;
 
+	virtual RID texture_create_render_texture(int p_width, int p_height, int p_layers) = 0;
+
 	//these two APIs can be used together or in combination with the others.
 	virtual void texture_2d_placeholder_initialize(RID p_texture) = 0;
 	virtual void texture_2d_layered_placeholder_initialize(RID p_texture, RenderingServer::TextureLayeredType p_layered_type) = 0;
diff --git a/servers/rendering_server.cpp b/servers/rendering_server.cpp
index 260835a..c8dc8ea 100644
--- a/servers/rendering_server.cpp
+++ b/servers/rendering_server.cpp
@@ -1699,6 +1699,7 @@ void RenderingServer::_bind_methods() {
 	ClassDB::bind_method(D_METHOD("texture_set_force_redraw_if_visible", "texture", "enable"), &RenderingServer::texture_set_force_redraw_if_visible);
 	ClassDB::bind_method(D_METHOD("texture_get_rd_texture", "texture", "srgb"), &RenderingServer::texture_get_rd_texture, DEFVAL(false));
 	ClassDB::bind_method(D_METHOD("texture_get_native_handle", "texture", "srgb"), &RenderingServer::texture_get_native_handle, DEFVAL(false));
+	ClassDB::bind_method(D_METHOD("texture_create_render_texture", "width", "height", "layers"), &RenderingServer::texture_create_render_texture, DEFVAL(false));
 
 	BIND_ENUM_CONSTANT(TEXTURE_LAYERED_2D_ARRAY);
 	BIND_ENUM_CONSTANT(TEXTURE_LAYERED_CUBEMAP);
diff --git a/servers/rendering_server.h b/servers/rendering_server.h
index 3fe3e18..8043dec 100644
--- a/servers/rendering_server.h
+++ b/servers/rendering_server.h
@@ -158,7 +158,7 @@ public:
 
 	virtual RID texture_get_rd_texture(RID p_texture, bool p_srgb = false) const = 0;
 	virtual uint64_t texture_get_native_handle(RID p_texture, bool p_srgb = false) const = 0;
-
+	virtual RID texture_create_render_texture(int p_width, int p_height, int p_layers) = 0;
 	/* SHADER API */
 
 	enum ShaderMode {
